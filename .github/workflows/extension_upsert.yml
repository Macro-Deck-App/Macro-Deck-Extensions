name: Add/Update Extension

on:
  workflow_dispatch:
    inputs:
      github_http_url:
        description: 'GitHub Repo HTTP URL'
        required: true
        type: string
      commit_ref:
        description: 'Commit Ref (tag/branch/commit)'
        required: true
        type: string

permissions:
  contents: write
  pull-requests: write
  
jobs:
  pull_submodule:
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v3
      
      - name: Get manifest details
        run: |
          mkdir temp
          cd temp
          git clone "${{ inputs.github_http_url }}" .
          git checkout "${{ inputs.commit_ref }}"
          ext_type=$(git cat-file -p HEAD:ExtensionManifest.json | jq -r '[.type][0]')
          package_id=$(git cat-file -p HEAD:ExtensionManifest.json | jq -r '[.packageId][0]')
          if [ $ext_type != "Plugin" ]; then ext_type='IconPack'; fi
          echo "ext_type=$ext_type" >> $GITHUB_ENV
          echo "package_id=$package_id" >> $GITHUB_ENV
          cd ..
      
      - name: Get Output Path
        id: ext_type_check
        run: |
          if [ ${{ env.ext_type }} = 'Plugin' ]; then 
            echo 'output_path=Plugins' >> $GITHUB_ENV
          else
            echo 'output_path=IconPacks' >> $GITHUB_ENV
          fi
      
      - name: Clean branch
        run: |
          git clean -xfd
          git submodule foreach --recursive git clean -xfd
          git reset --hard
          git submodule foreach --recursive git reset --hard
          git submodule update --init --recursive
          
      - name: Add Submodule (If Needed)
        id: add_submodule
        run: | 
          if [ ! -d "./${{ env.output_path }}/${{ env.package_id }}" ]; then
            git submodule add "${{ inputs.github_http_url }}" "./${{ env.output_path }}/${{ env.package_id }}"
          else
            git --git-dir "./${{ env.output_path }}/${{ env.package_id }}/.git" rev-parse HEAD | echo "current_hash=$(</dev/stdin)" >> $GITHUB_ENV
          fi
          
      - name: Update Submodule
        run: |
          cd "./${{ env.output_path }}/${{ env.package_id }}"
          git fetch origin "${{ inputs.commit_ref }}":"${{ inputs.commit_ref }}"
          git checkout "${{ inputs.commit_ref }}"
          cd ../..
          
      - name: Sanity Check
        run: |
          cd "./${{ env.output_path }}/${{ env.package_id }}"
          if [ ! -z "${{ env.current_hash }}" ]; then
            result=0
            
            # ExtensionManifest.json check
            old_manifest_version=$(git cat-file -p ${{ env.current_hash }}:ExtensionManifest.json | jq -r '[.version][0]')
            new_manifest_version=$(git cat-file -p HEAD:ExtensionManifest.json | jq -r '[.version][0]')
            if [ $old_manifest_version == $new_manifest_version ]; then
              echo "::error::ExtensionManifest.json 'version' key was not updated"
              result=1
            fi

            if [ ${{ env.ext_type }} = 'Plugin' ]; then 
              # csproj check
              old_csproj_version=$(git cat-file -p ${{ env.current_hash }}:$(ls *.csproj | head -n 1) | grep -oPm1 "(?<=<Version>)[^<]+")
              new_csproj_version=$(git cat-file -p HEAD:$(ls *.csproj | head -n 1) | grep -oPm1 "(?<=<Version>)[^<]+")
              if [ $old_csproj_version == $new_csproj_version ]; then
                echo "::error::csproj file 'version' node was not updated"
                result=1
              fi

              # ExntensionManifest <-> csproj check
              if [ ! -z $new_manifest_version ] && [ ! -z $new_csproj_version ] && [ $new_manifest_version != $new_csproj_version ]; then
                echo "::error::ExtensionManifest.json 'version' token does not match the csproj file's 'Version' node"
                result=1
              fi
            fi

            if [ $result -ne 0 ]; then
              exit 1
            fi
          else
            result=0
          
            # Manifest check
            manifest_version="$(git cat-file -p HEAD:ExtensionManifest.json | jq -r '[.version][0]')"
            if [ -z manifest_version ]; then 
              echo "::error::ExtensionManifest.json 'version' key does not exist"
              result=1
            fi
            
            if [ ${{ env.ext_type }} = 'Plugin' ]; then 
              # csproj check
              csproj_version="$(git cat-file -p HEAD:$(ls *.csproj | head -n 1) | grep -oPm1 "(?<=<Version>)[^<]+")"
              if [ -z csproj_version ]; then
                echo "::error::csproj file 'version' key does not exist"
                result=1
              fi

              # ExntensionManifest <-> csproj check
              if [ ! -z $manifest_version ] && [ ! -z $csproj_version ] && [ $manifest_version != $csproj_version ]; then
                echo "::error::ExtensionManifest.json 'version' token does not match the csproj file's 'Version' node"
                result=1
              fi
            fi
            
            if [ $result -ne 0 ]; then
              exit 1
            fi
          fi
          cd ../..
          
      - name: Create Pull Request
        uses: peter-evans/create-pull-request@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          commit-message: Update ${{ env.ext_type }} - ${{ env.package_id }}
          title: '[${{ env.ext_type }} Update] ${{ env.package_id }} => ${{ inputs.commit_ref }}'
          body: |
            ## ${{ env.ext_type }} Update
            
            <table>
              <tr>
                <td><b>Plugin Type</b></td>
                <td>${{ env.output_path }}</td>
              </tr>
              <tr>
                <td><b>GitHub HTTP URL</b></td>
                <td>${{ inputs.github_http_url }}</td>
              </tr>
              <tr>
                <td><b>Package ID</b></td>
                <td>${{ env.package_id }}</td>
              </tr>
              <tr>
                <td><b>Commit Ref</b></td>
                <td>${{ inputs.commit_ref }}</td>
              </tr>
            </table>
          branch: feature/update-${{ env.package_id }}
          delete-branch: true
